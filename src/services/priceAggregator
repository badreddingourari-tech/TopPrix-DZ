const productUtils = require('../utils/productUtils');
const safeScraper = require('../utils/safeScraper');

class PriceAggregator {
    constructor() {
        this.sources = ['ouedkniss', 'google', 'local_stores'];
    }

    async aggregatePrices(productName, options = {}) {
        const {
            maxResults = 15,
            includeImages = true,
            sortBy = 'price'
        } = options;

        console.log(`ðŸ” ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ù„Ù€: ${productName}`);

        // Ø¬Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ù…ØµØ§Ø¯Ø± Ù…ØªØ¹Ø¯Ø¯Ø©
        const allResults = await safeScraper.searchMultipleSources(productName, maxResults);

        // Ø§Ø³ØªØ®Ø¯Ø§Ù… utils Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ Ù„Ø¯ÙŠÙƒ Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        const cleanedResults = productUtils.cleanProductData(allResults);

        // ØªØ­Ù„ÙŠÙ„ ÙˆØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
        const analyzedResults = this.analyzePrices(cleanedResults);

        return {
            product: productName,
            totalResults: analyzedResults.length,
            priceRange: this.getPriceRange(analyzedResults),
            bestDeals: this.getBestDeals(analyzedResults),
            allResults: analyzedResults
        };
    }

    analyzePrices(products) {
        return products.map(product => {
            const priceAnalysis = this.analyzePrice(product.price);
            return {
                ...product,
                priceValue: priceAnalysis.value,
                currency: priceAnalysis.currency,
                confidence: priceAnalysis.confidence
            };
        });
    }

    analyzePrice(priceText) {
        // ØªØ­Ù„ÙŠÙ„ Ù†Øµ Ø§Ù„Ø³Ø¹Ø± Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø±Ù‚Ù…ÙŠØ©
        const priceMatch = priceText.match(/(\d+[\d,.]*)/);
        return {
            value: priceMatch ? parseFloat(priceMatch[1].replace(/,/g, '')) : 0,
            currency: 'DZD',
            confidence: priceMatch ? 0.8 : 0.3
        };
    }

    getPriceRange(products) {
        const prices = products
            .map(p => p.priceValue)
            .filter(p => p > 0)
            .sort((a, b) => a - b);

        return {
            min: prices[0] || 0,
            max: prices[prices.length - 1] || 0,
            average: prices.length ? prices.reduce((a, b) => a + b) / prices.length : 0
        };
    }

    getBestDeals(products, count = 3) {
        return products
            .filter(p => p.priceValue > 0)
            .sort((a, b) => a.priceValue - b.priceValue)
            .slice(0, count);
    }
}

module.exports = new PriceAggregator();
